Chapter 7. rise graph databases one hand ’ producing data mass scale , prompting likes Google , Amazon , Facebook come intelligent ways deal , hand ’ faced data ’ becoming interconnected ever . Graphs networks pervasive lives . presenting several motivating examples , hope teach reader recognize graph problem reveals . chapter ’ look leverage connections ’ worth using graph database , demonstrate use Neo4j , popular graph database . 7.1 . Introducing connected data graph databases Let ’ start familiarizing concept connected data representation graph data . Connected data —As name indicates , connected data characterized fact data hand relationship makes connected . Graphs —Often referred sentence connected data . Graphs well suited represent connectivity data meaningful way . Graph databases —Introduced chapter 6. reason subject meriting particular attention , besides fact data increasing size , ’ also becoming interconnected . much effort needed come well-known examples connected data . prominent example data takes network form social media data . Social media allows us share exchange data networks , thereby generating great amount connected data . illustrate simple example . Let ’ assume two people data , User1 User2 . Furthermore , know first name last name User1 ( first name : Paul last name : Beun ) User2 ( first name : Jelme last name : Ragnar ) . natural way representing could drawing whiteboard , shown figure 7.1.The terminology figure 7.1 described : Entities —We two entities represent people ( User1 User2 ) . entities properties “ name ” “ lastname ” . Properties —The properties defined key-value pairs . graph also infer User1 “ name ” property Paul knows User2 “ name ” property Jelme . Relationships —This relationship Paul Jelme . Note relationship direction : ’ Paul “ knows ” Jelme way around . User1 User2 represent people could therefore grouped . Labels —In graph database , one group nodes using labels . User1 User2 could case labeled “ User ” . Connected data often contains many entities connections . figure 7.2 see extensive graph . Two entities included : Country1 name Cambodia Country2 name Sweden . Two relationships exist : “ Has_been_in ” “ Is_born_in ” . previous graph , entities included property , relationships also contain property . graphs known property graphs . relationship connecting nodes User1 Country1 type “ Has_been_in ” property “ Date ” represents data value . Similarly , User2 connected Country2 different type relationship , type “ Is_born_in ” . Note types relationships provide us context relationships nodes . Nodes multiple relationships . Figure 7.2. complicated connected data example two entities included ( Country1 Country2 ) two new relationships ( “ Has_been_in ” “ Is_born_in ” ) kind representation data gives us intuitive way store connected data . explore data need traverse graph following predefined paths find patterns ’ searching . one would like know Paul ? Translated graph database terminology , ’ like find pattern “ Paul in. ” answer , ’ start node name “ Paul ” traverse Cambodia via relationship “ Has_been_in ” . Hence graph traversal , corresponds database query , would following : 1. starting node—In case node name property “ Paul ” 2. traversal path—In case path starting node Paul going Cambodia 3 . End node—Country node name property “ Cambodia ” better understand graph databases deal connected data , ’ appropriate expand bit graphs general . Graphs extensively studied domains computer science mathematics field called graph theory . Graph theory study graphs , graphs represent mathematical structures used model pairwise relations objects , shown figure 7.3. makes appealing structure lends visualizing connected data . graph defined vertices ( also known nodes graph database world ) edges ( also known relationships ) . concepts form basic fundamentals graph data structures based . Figure 7.3. core graph consists nodes ( also known vertices ) edges ( connect vertices ) , known mathematical definition graph . collections objects represent graph . Compared data structures , distinctive feature connected data nonlinear nature : entity connected via variety relationship types intermediate entities paths . graphs , make subdivision directed undirected graphs . edges directed graph have—how could otherwise—a direction . Although one could argue every problem could somehow represented graph problem , ’ important understand ’ ideal ’ . 7.1.1. use graph database ? quest determining graph database one use could involved process undertake . One important aspect decision making process finding right representation data . Since early 1970s common type database one rely relational one . Later , others emerged , hierarchical database ( example , IMS ) , graph database ’ closest relative : network database ( example , IDMS ) . last decades landscape become much diverse , giving end-users choice depending specific needs . Considering recent development data ’ becoming available , two characteristics well suited highlighted . first one size data complexity data , shown figure 7.4 . Figure 7.4. figure illustrates positioning graph databases two dimensional space one dimension represents size data one dealing , dimension represents complexity terms connected data . relational databases longer cope complexity data set connectedness , size , graph databases may best option . figure 7.4 indicates , ’ need rely graph database data complex still small . Though “ small ” relative thing , ’ still talking hundreds millions nodes . Handling complexity main asset graph database ultimate “ ” ’ use . explain kind complexity meant , first think traditional relational database works . Contrary name relational databases indicates , much relational except foreign keys primary keys relate tables . contrast , relationships graph databases first-class citizens . aspect , lend well modeling querying connected data . relational database would rather strive minimizing data redundancy . process known database normalization , table decomposed smaller ( less redundant ) tables maintaining information intact . normalized database one needs conduct changes attribute one table . aim process isolate data changes one table . Relational database management systems ( RDBMS ) good choice database data fits nicely tabular format . relationships data expressed joining tables . fit starts downgrade joins become complicated , especially become many-to-many joins . Query time also increase data size starts increasing , maintaining database challenge . factors hamper performance database . Graph databases , hand , inherently store data nodes relationships . Although graph databases classified NoSQL type database , trend present category right exists . One seeks justification noting types NoSQL databases aggregation-oriented , graph databases ’ . relational database might , example , table representing “ people ” properties . person related people kinship ( friendship , ) ; row might represent person , connecting rows people table would immensely difficult job . add variable holds unique identifier first child extra one hold ID second child ? stop ? Tenth child ? alternative would use intermediate table child-parent relationships , ’ need separate one relationship types like friendship . last case ’ get column proliferation table proliferation : one relationship table type relationship . Even somehow succeed modeling data way family relations present , ’ need difficult queries get answer simple questions “ would like grandsons John McBain. ” First need find John McBain ’ children . find children , need find . time found grandsons , hit “ people ” table three times : 1 . Find McBain fetch children . 2 . Look children IDs got get IDs children . 3 . Find grandsons McBain . Figure 7.5 shows recursive lookups relation database necessary get John McBain grandsons everything single table . Figure 7.5 . Recursive lookup version 1 : data one table Figure 7.6 another way model data : parent-child relationship separate table . Figure 7.6 . Recursive lookup version 2 : using parent-child relationship table Recursive lookups inefficient , say least . Graph databases shine type complexity arises . Let ’ look popular among . 7.2 . Introducing Neo4j : graph database Connected data generally stored graph databases . databases specifically designed cope structure connected data . landscape available graph databases rather diverse days . three most-known ones order decreasing popularity Neo4j , OrientDb , Titan . showcase case study ’ choose popular one moment writing ( see http : //db-engines.com/en/ranking/graph+dbms , September 2015 ) . Neo4j graph database stores data graph containing nodes relationships ( allowed contain properties ) . type graph database known property graph well suited storing connected data . flexible schema give us freedom change data structure needed , providing us ability add new data new relationships needed . ’ open source project , mature technology , easy install , user-friendly , well documented . Neo4j also browser-based interface facilitates creation graphs visualization purposes . follow along , would right moment install Neo4j . Neo4j downloaded http : //neo4j.com/download/ . necessary steps successful installation summarized appendix C. let ’ introduce four basic structures Neo4j : Nodes —Represent entities documents , users , recipes , . Certain properties could assigned nodes . Relationships —Exist different nodes . accessed either stand-alone nodes ’ attached . Relationships also contain properties , hence name property graph model . Every relationship name direction , together provide semantic context nodes connected relationship . Properties —Both nodes relationships properties . Properties defined key-value pairs . Labels —Can used group similar nodes facilitate faster traversal graphs . conducting analysis , good habit design database carefully fits queries ’ like run road performing analysis . Graph databases pleasant characteristic ’ whiteboard friendly . one tries draw problem setting whiteboard , drawing closely resemble database design defined problem . Therefore , whiteboard drawing would good starting point design database . retrieve data ? explore data , need traverse graph following predefined paths find patterns ’ searching . Neo4j browser ideal environment create play around connected data get right kind representation optimal queries , shown figure 7.7. flexible schema graph database suits us well . browser retrieve data rows graph . Neo4j query language ease creation query capabilities graphs . Figure 7.7 . Neo4j 2.2.5 interface resolved query chapter case study Cypher highly expressive language shares enough SQL enhance learning process language . following section , ’ create data using Cypher insert Neo4j . play around data . 7.2.1 . Cypher : graph query language Let ’ introduce Cypher basic syntax graph operations . idea section present enough Cypher get us started using Neo4j browser . end section able create connected data using Cypher Neo4j browser run basic queries retrieve results query . extensive introduction Cypher visit http : //neo4j.com/docs/stable/cypher-query-lang.html . ’ start drawing simple social graph accompanied basic query retrieve predefined pattern example . next step ’ draw complex graph allow us use complicated queries Cypher . help us get acquainted Cypher move us path bringing use case reality . Moreover , ’ show create simulated connected data using Cypher . Figure 7.8 shows simple social graph two nodes , connected relationship type “ knows ” . nodes properties “ name ” “ lastname ” . Figure 7.8. example simple social graph two users one relationship , ’ like find following pattern , “ Paul know ? ” ’ query using Cypher . find pattern Cypher , ’ start Match clause . query ’ start searching node User name property “ Paul ” . Note node enclosed within parentheses , shown code snippet , relationship enclosed square brackets . Relationships named colon ( : ) prefix , direction described using arrows . placeholder p2 contain User nodes relationship type “ knows ” inbound relationship . return clause retrieve results query . 1 2 Match ( p1 : User { name : 'Paul ' } ) - [ : knows ] - > ( p2 : User ) Return p2.name copy Notice close relationship formulated question verbally way graph database translates traversal . Neo4j , impressive expressiveness made possible graph query language , Cypher . make examples interesting , let ’ assume data represented graph figure 7.9 . Figure 7.9. complicated connected data example several interconnected nodes different types insert connected data figure 7.9 Neo4j using Cypher . write Cypher commands directly browser-based interface Neo4j , alternatively Python driver ( see http : //neo4j.com/developer/python/ overview ) . good way get hands-on feeling connected data graph databases . write appropriate create statement Cypher , first good understanding data ’ like store nodes relationships , properties , whether labels would useful . first decision decide data regarded nodes relationships provide semantic context nodes . figure 7.9 ’ chosen represent users countries nodes . Data provides information specific node , example name ’ associated node , represented property . data provides context two nodes considered relationship . Nodes share common features , example Cambodia Sweden countries , also grouped labels . figure 7.9 already done . following listing demonstrate different objects could encoded Cypher one big create statement . aware Cypher case sensitive . Listing 7.1 . Cypher data creation statement CREATE ( user1 : User { name : 'Annelies ' } ) , ( user2 : User { name : 'Paul ' , LastName : 'Beun ' } ) , ( user3 : User { name : 'Muhuba ' } ) , ( user4 : User { name : 'Jelme ' , LastName : 'Ragnar ' } ) , ( country1 : Country { name : 'Mongolia ' } ) , ( country2 : Country { name : 'Cambodia ' } ) , ( country3 : Country { name : 'New Zealand ' } ) , ( country4 : Country { name : 'Sweden ' } ) , ( food1 : Food { name : 'Sushi ' } ) , ( hobby1 : Hobby { name : 'Travelling ' } ) , ( user1 ) - [ : Has_been_in ] - > ( country1 ) , ( user1 ) - [ : Has_been_in ] - > ( country2 ) , ( user1 ) - [ : Has_been_in ] - > ( country3 ) , ( user2 ) - [ : Has_been_in ] - > ( country2 ) , ( user1 ) - [ : Is_mother_of ] - > ( user4 ) , ( user2 ) - [ : knows ] - > ( user4 ) , ( user1 ) - [ : Is_friend_of ] - > ( user3 ) , ( user2 ) - [ : Likes ] - > ( food1 ) , ( user3 ) - [ : Likes ] - > ( food1 ) , ( user4 ) - [ : Is_born_in ] - > ( country4 ) Running create statement one go advantage success execution ensure us graph database successfully created . error exists , graph ’ created . real scenario , one also define indexes constraints ensure fast lookup search entire database . ’ done simulated data set small . However , easily done using Cypher . Consult Cypher documentation find indexes constraints ( http : //neo4j.com/docs/stable/cypherdoc-labels-constraints-and-indexes.html ) . ’ created data , query . following query return nodes relationships database : Figure 7.10 shows database ’ created . compare graph graph ’ envisioned whiteboard . whiteboard grouped nodes people label “ User ” nodes countries label “ Country ” . Although nodes figure ’ represented labels , labels present database . Besides , also miss node ( Hobby ) relationship type “ Loves ” . easily added merge statement create node relationship ’ exist already : Figure 7.10. graph drawn figure 7.9 created Neo4j web interface . nodes ’ represented labels names . infer graph ’ missing label Hobby name Traveling . reason forgotten include node corresponding relationship create statement . Merge ( user3 ) - [ : Loves ] - > ( hobby1 ) copy ask many questions . example : Question 1 : countries Annelies visited ? Cypher code create answer ( shown figure 7.11 ) Match ( u : User { name : 'Annelies ' } ) – [ : Has_been_in ] - > ( c : Country ) Return u.name , c.name copy Question 2 : ? Cypher code ( explained figure 7.12 ) Match ( ) - [ r : Has_been_in ] - > ( ) Return r LIMIT 25 Figure 7.13 . Results question 2 : ? results traversal shown graph representation Neo4j . see Paul , addition Annelies , also Cambodia . question 2 chosen specify start node . Therefore , Cypher go nodes present database find outgoing relationship type “ Has_been_in ” . One avoid specifying starting node since , depending size database , query could take long time converge . Playing around data obtain right graph database also means lot data deletion . Cypher delete statement suitable deleting small amounts data . following query demonstrates delete nodes relationships database : MATCH ( n ) Optional MATCH ( n ) - [ r ] - ( ) Delete n , r ’ acquainted connected data basic knowledge ’ managed graph database , go step look real , live applications connected data . social graph , example , used find clusters tightly connected nodes inside graph communities . People cluster ’ know introduced . concept searching tightly connected nodes , nodes significant amount features common , widely used concept . next section ’ use idea , aim find clusters inside ingredient network . 7.3 . Connected data example : recipe recommendation engine One popular use cases graph databases development recommender engines . Recommender engines became widely adopted promise create relevant content . Living era abundance data overwhelming many consumers . Enterprises saw clear need inventive attract customers personalized content , thereby using strengths recommender engines . case study ’ recommend recipes based dish preferences users network ingredients . data preparation ’ use Elasticsearch quicken process allow focus actual graph database . main purpose replace ingredients list “ dirty ” downloaded data ingredients “ clean ” list . skipped ahead chapter , might good least read appendix installing Elasticsearch running computer . always download index ’ use Manning download page chapter paste local Elasticsearch data directory ’ feel like bothering chapter 6 case study . download following information Manning website chapter : Three .py code files .ipynb counterparts Data Preparation Part 1 —Will upload data Elasticsearch ( alternatively paste downloadable index local Elasticsearch data folder ) Data Preparation Part 2 —Will move data Elasticsearch Neo4j Exploration & Recommender System Three data files Ingredients ( .txt ) —Self-compiled ingredients file Recipes ( .json ) —Contains ingredients Elasticsearch index ( .zip ) —Contains “ gastronomical ” Elasticsearch index use skip data preparation part 1 everything need , let ’ look research goal steps need take achieve . 7.3.1 . Step 1 : Setting research goal Let ’ look ’ come follow data science process ( figure 7.14 ) . Figure 7.14 . Data science process overview applied connected data recommender model primary goal set recommender engine would help users cooking website find right recipe . user gets like several recipes ’ base dish recommendations ingredients ’ overlap recipes network . simple intuitive approach , yet already yields fairly accurate results . Let ’ look three data elements require . 7.3.2 . Step 2 : Data retrieval exercise require three types data : Recipes respective ingredients list distinct ingredients like model least one user preference certain dishes always , divide internally available created data externally acquired data . Internal data —We ’ user preferences ingredients lying around , smallest part data easily created . manually input preferences enough create recommendation . user gets interesting accurate results feedback gives . ’ input user preferences later case study . list ingredients manually compiled remain relevant years come , feel free use list downloadable material purpose , commercially otherwise . External data —Recipes different matter . Thousands ingredients exist , combined millions dishes . luck , however , pretty big list freely available https : //github.com/fictivekin/openrecipes . Many thanks Fictive Kin valuable data set hundred thousand recipes . Sure duplicates , ’ hurt use case badly . two data files disposal : list 800+ ingredients ( ingredients.txt ) hundred thousand recipes recipes.json file . sample ingredients list seen following listing . Listing 7.2 . Ingredients list text file sample Ditalini Egg Noodles Farfalle Fettuccine Fusilli Lasagna Linguine Macaroni Orzo copy “ openrecipes ” JSON file contains hundred thousand recipes multiple properties publish date , source location , preparation time , description , . ’ interested name ingredients list . sample recipe shown following listing . Listing 7.3. sample JSON recipe { `` _id '' : { `` $ oid '' : `` 5160756b96cc62079cc2db15 '' } , `` name '' : `` Drop Biscuits Sausage Gravy '' , `` ingredients '' : `` Biscuits\n3 cups All-purpose Flour\n2 Tablespoons Baking Powder\n1/2 teaspoon Salt\n1-1/2 stick ( 3/4 Cup ) Cold Butter , Cut Pieces\n1-1/4 cup Butermilk\n SAUSAGE GRAVY\n1 pound Breakfast Sausage , Hot Mild\n1/3 cup All-purpose Flour\n4 cups Whole Milk\n1/2 teaspoon Seasoned Salt\n2 teaspoons Black Pepper , Taste '' , `` url '' : `` http : //thepioneerwoman.com/cooking/2013/03/drop-biscuits-and- sausage-gravy/ '' , `` image '' : `` http : //static.thepioneerwoman.com/cooking/files/2013/03/ bisgrav.jpg '' , `` ts '' : { `` $ date '' : 1365276011104 } , `` cookTime '' : `` PT30M '' , `` source '' : `` thepioneerwoman '' , `` recipeYield '' : `` 12 '' , `` datePublished '' : `` 2013-03-11 '' , `` prepTime '' : `` PT10M '' , `` description '' : `` Late Saturday afternoon , Marlboro Man returned home soccer-playing girls , returned home ... '' } ’ dealing text data , problem two-fold : first , preparing textual data described text mining chapter . , data thoroughly cleansed , used produce recipe recommendations based network ingredients . chapter ’ focus text data preparation described elsewhere , ’ allow luxury shortcut upcoming data preparation . 7.3.3 . Step 3 : Data preparation two data files disposal , need combine one graph database . “ dirty ” recipes data poses problem address using clean ingredients list use search engine NoSQL database Elasticsearch . already relied Elasticsearch previous chapter clean recipe data us implicitly creates index . search data link ingredient every recipe occurs . could clean text data using pure Python , text mining chapter , shows ’ good aware strong points NoSQL database ; ’ pin single technology , use together benefit project . Let ’ start entering recipe data Elasticsearch . ’ understand ’ happening , please check case study chapter 6 become clear . Make sure turn local Elasticsearch instance activate Python environment Elasticsearch module installed running code snippet following listing . ’ recommended run code “ ” Ipython ( Jupyter ) prints every recipe key screen browser handle much output . Either turn print statements run another Python IDE . code snippet found “ Data Preparation Part 1.py ” . Listing 7.4 . Importing recipe data Elasticsearch everything went well , Elasticsearch index name “ gastronomical ” populated thousands recipes . Notice allowed duplicates recipe assigning name recipe document key . , instance , recipe called “ lasagna ” salmon lasagna , beef lasagna , chicken lasagna , type . single recipe selected prototype lasagna ; uploaded Elasticsearch name : “ lasagna ” . choice , feel free decide otherwise . significant impact , ’ see later . door open systematic upload local graph database . Make sure local graph database instance turned applying following code . username database default Neo4j password Neo4ja ; make sure adjust local setup . ’ also require Neo4j-specific Python library called py2neo . ’ already , would time install virtual environment using pip install py2neo conda install py2neo using Anaconda . , advised code crash browser run directly Ipython Jupiter . code listing found “ Data Preparation Part 2.py ” . Listing 7.5 . Using Elasticsearch index fill graph database Great , ’ proud owner graph database filled recipes ! ’ time connected data exploration . 7.3.4 . Step 4 : Data exploration data want , manually explore using Neo4j interface http : //localhost:7474/browser/ . Nothing stops running Cypher code environment , Cypher also executed via py2neo library . One interesting question pose ingredients occurring recipes ? likely get digestive system randomly selected ate dishes database ? py2neo import Graph , authenticate , Node , Relationship authenticate ( `` localhost:7474 '' , `` user '' , `` password '' ) graph_db = Graph ( `` http : //localhost:7474/db/data/ '' ) graph_db.cypher.execute ( `` MATCH ( REC : Recipe ) - [ r : Contains ] - > ( ING : Ingredient ) ING , count ( r ) num RETURN ING.Name Name , num ORDER num DESC LIMIT 10 ; '' ) query created Cypher says : recipes ingredients , count number relations per ingredient return ten ingredients relations respective counts . results shown figure 7.15 . Figure 7.15 . Top 10 ingredients occur recipes top 10 list figure 7.15 ’ come surprise . salt proudly top list , ’ shocked find vascular diseases number one killer western countries . Another interesting question comes mind different perspective : recipes require ingredients ? py2neo import Graph , Node , Relationship graph_db = Graph ( `` http : //neo4j : neo4ja @ localhost:7474/db/data/ '' ) graph_db.cypher.execute ( `` MATCH ( REC : Recipe ) - [ r : Contains ] - > ( ING : Ingredient ) REC , count ( r ) num RETURN REC.Name Name , num ORDER num DESC LIMIT 10 ; '' ) copy query almost , instead returning ingredients , demand recipes . result figure 7.16 . Figure 7.16 . Top 10 dishes created greatest diversity ingredients might surprising sight . Spaghetti Bolognese hardly sounds like type dish would require 59 ingredients . Let ’ take closer look ingredients listed Spaghetti Bolognese . py2neo import Graph , Node , Relationship graph_db = Graph ( `` http : //neo4j : neo4ja @ localhost:7474/db/data/ '' ) graph_db.cypher.execute ( `` MATCH ( REC1 : Recipe { Name : 'Spaghetti Bolognese ' } ) - [ r : Contains ] - > ( ING : Ingredient ) RETURN REC1.Name , ING.Name ; '' ) Cypher query merely lists ingredients linked Spaghetti Bolognese . Figure 7.17 shows result Neo4j web interface . Figure 7.17 . Spaghetti Bolognese possible ingredients Let ’ remind remark made indexing data Elasticsearch . quick Elasticsearch search Spaghetti Bolognese shows us occurs multiple times , instances used link ingredients Spaghetti Bolognese recipe . ’ look Spaghetti Bolognese single recipe collection ways people create “ Spaghetti Bolognese. ” makes interesting way look data . People create version dish ketchup , red wine , chicken might even add soup . “ Spaghetti Bolognese ” dish open interpretation , wonder many people love . Spaghetti Bolognese story interesting distraction came . ’ time recommend dishes gourmand “ Ragnar ” . 7.3.5 . Step 5 : Data modeling knowledge data slightly enriched , get goal exercise : recommendations . introduce user call “ Ragnar , ” likes couple dishes . new information needs absorbed graph database expect suggest new dishes . Therefore , let ’ create Ragnar ’ user node recipe preferences . Listing 7.6 . Creating user node likes certain recipes Neo4j graph database listing 7.6 food connoisseur Ragnar added database along preference dishes . select Ragnar Neo4j interface , get figure 7.18 . Cypher query Figure 7.18. user Ragnar likes several dishes MATCH ( U : User ) - [ r : Likes ] - > ( REC : Recipe ) RETURN U , REC LIMIT 25 copy surprises figure 7.18 : many people like Spaghetti Bolognese , Scandinavian gastronomist Ragnar . simple recommendation engine like build , ’ left us ask graph database give us nearest dishes terms ingredients . , basic approach recommender systems ’ take account factors Dislike ingredient dish . amount like dislike . score 10 instead binary like ’ like could make difference . amount ingredient present dish . threshold certain ingredient become apparent taste . Certain ingredients , spicy pepper , represent bigger impact smaller dose ingredients would . Food allergies . implicitly modeled like dislike dishes certain ingredients , food allergy important single mistake fatal . Avoidance allergens overwrite entire recommendation system . Many things ponder . might come bit surprise , single Cypher command suffice . py2neo import Graph , Node , Relationship graph_db = Graph ( `` http : //neo4j : neo4ja @ localhost:7474/db/data/ '' ) graph_db.cypher.execute ( `` MATCH ( USR1 : User { Name : 'Ragnar ' } ) - [ l1 : Likes ] - > ( REC1 : Recipe ) , ( REC1 ) - [ c1 : Contains ] - > ( ING1 : Ingredient ) ING1 , REC1 MATCH ( REC2 : Recipe ) - [ c2 : Contains ] - > ( ING1 : Ingredient ) REC1 < > REC2 RETURN REC2.Name , count ( ING1 ) IngCount ORDER IngCount DESC LIMIT 20 ; '' ) copy First recipes Ragnar likes collected . ingredients used fetch dishes share . ingredients counted connected dish ranked many common ingredients . top 20 dishes kept ; results table figure 7.19 . Figure 7.19 . Output recipe recommendation ; top 20 dishes user may love figure 7.19 deduce ’ time Ragnar try Spaghetti Meatballs , dish made immortally famous Disney animation Lady Tramp . sound like great recommendation somebody fond dishes containing pasta meatballs , see ingredient count , many ingredients back suggestion . give us small hint ’ behind , show preferred dishes , top recommendations , overlapping ingredients single summary graph image . 7.3.6 . Step 6 : Presentation Neo4j web interface allows us run model retrieve nice-looking graph summarizes part logic behind recommendations . shows recommended dishes linked preferred dishes via ingredients . shown figure 7.20 final output case study . Figure 7.20 . Interconnectedness user-preferred dishes top 10 recommended dishes via sub-selection overlapping ingredients beautiful graph image conclude chapter knowledge Ragnar tasty dishes look forward . ’ forget try recommendation system inserting preferences . 7.4 . Summary chapter learned Graph databases especially useful encountering data relationships entities important entities . Compared NoSQL databases , handle biggest complexity least data . Graph data structures consist two main components : Nodes —These entities . case study , recipes ingredients . Edges —The relationships entities . Relationships , like nodes , kinds types ( example “ contains , ” “ likes , ” “ ” ) specific properties names , weights , measures . looked Neo4j , currently popular graph database . instruction install , consult appendix B. looked adding data Neo4j , querying using Cypher , access web interface . Cypher Neo4j database-specific query language , looked examples . also used case study part dishes recommender system . chapter ’ case study made use Elasticsearch clean huge recipe data dump . converted data Neo4j database recipes ingredients . goal case study recommend dishes people based previously shown interest dishes . made use connectedness recipes via ingredients . py2neo library enabled us communicate Neo4j server Python . turns graph database useful implementing recommendation system also data exploration . One things found diversity ( ingredient-wise ) Spaghetti Bolognese recipes . used Neo4j web interface create visual representation get dish preferences dish recommendations via ingredient nodes . sitemap Prev Chapter